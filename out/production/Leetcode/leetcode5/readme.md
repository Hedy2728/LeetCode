# LeetCode5. Longest Palindromic Substring
## 思路：三种方法
### 方法一： 从中心开始，检查是否为回文字符串
+ 首先定义一个返回最长回文字符串长度的函数` public int expandCenter(String cur, int i, int j)`
+ 第二步开始从字符串的0位开始遍历，依次扩展，此时应该注意字符串的奇偶问题，奇偶分开扩展，选择最长的子字符串，并记录下中心扩展位置
+ 返回原始字符串对应的位置和长度即可得到最长回文子序列
+ 发现一个很神奇的事情，运算符的优先级，以下两种表达方式是一样的，右移运算符的优先级比加减号低

```
end = i + (len>>1);     begin = i - (len>>1);
end = i + len/2;        begin = i - len/2;
```

### 方法二：从首位开始依次遍历
+ 此时，看其子字符串是否为回文序列，当i遍历完成时，j已经走到字符型末尾，i++，并存下最长子字符串的长度，i开始新的遍历时直接从i+size出发开始检测是否为回文

### 方法三：使用动态规划的方法，制作一个从i到j是否为回文的表，只做i>j的部分
+ 将i, j从label[len-1][len-1]开始，往前倒推，开始判断i, j位置上的字符是否相等，不相等则返回0，若相等还需看i, j两字符是否相邻（即j-i<2)，是则返回1，否则返回i, j相邻字符的label（此过程相当于做i,j之间是否为回文）
